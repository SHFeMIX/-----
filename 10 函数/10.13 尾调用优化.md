ES6新增了一项内存管理优化机制，让JavaScript引擎在满足条件是可以重用栈帧，这项优化非常适合尾调用，即外部函数的返回值是一个内部函数的返回值。
```javascript
function outerFunction() {
    return innerFunction()
}
```
在 ES6 优化之前，执行这个例子会在内存中发生如下操作。
(1) 执行到 outerFunction 函数体，第一个栈帧被推到栈上。
(2) 执行 outerFunction 函数体，到 return 语句。计算返回值必须先计算 innerFunction。
(3) 执行到 innerFunction 函数体，第二个栈帧被推到栈上。
(4) 执行 innerFunction 函数体，计算其返回值。
(5) 将返回值传回 outerFunction，然后 outerFunction 再返回值。
(6) 将栈帧弹出栈外。
在 ES6 优化之后，执行这个例子会在内存中发生如下操作。
(1) 执行到 outerFunction 函数体，第一个栈帧被推到栈上。
(2) 执行 outerFunction 函数体，到达 return 语句。为求值返回语句，必须先求值 innerFunction。 (3) 引擎发现把第一个栈帧弹出栈外也没问题，因为 innerFunction 的返回值也是 outerFunction
的返回值。
(4) 弹出 outerFunction 的栈帧。
(5) 执行到 innerFunction 函数体，栈帧被推到栈上。
(6) 执行 innerFunction 函数体，计算其返回值。
(7) 将 innerFunction 的栈帧弹出栈外。 很明显，第一种情况下每多调用一次嵌套函数，就会多增加一个栈帧。而第二种情况下无论调用多
少次嵌套函数，都只有一个栈帧。这就是 ES6 尾调用优化的关键:如果函数的逻辑允许基于尾调用将其 销毁，则引擎就会那么做。

### 尾调用优化的条件
尾调用优化的条件就是确定外部栈帧真的没有必要存在了，涉及条件如下：
* 代码在严格模式下执行
* 外部函数的返回值是对尾调用函数的调用
* 尾调用函数返回后不需要执行额外的逻辑
* 尾调用函数不是引用外部函数作用域中自由变量的闭包
**基本就是，调用外部函数和直接调用尾调用函数没任何区别的情况下才可以**

无论是递归尾调用还是非递归尾调用，都可以应用优化。引擎并不区分尾调用的是函数自身还是其他函数。不过，这个优化在递归场景下效果最明显，因为递归代码最容易在栈内存中迅速产生大量栈帧。