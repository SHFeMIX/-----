异步行为是为了优化因计算量打而时间长的操作。如果在等待其他操作完成的同时，即使运行其他指令，系统也能保持稳定，那么这样做就是务实的。
只要你不想为等待某个异步操作而阻塞线程执行，那么任何时候都可以使用。

### 同步与异步
同步行为对应内存中顺序执行的处理器指令。每条指令都会严格按照它们出现的顺序来执行，而每条指令执行后也能立即获得储存在本地的信息。这样的执行流程容易分析程序在执行到代码任意位置时的状态（比如变量的值）。
在程序执行的每一步都可以推断出程序的状态，因为后面的指令总是在前面的指令完成后才执行。

相对地，异步行为类似于系统中断，即当前晋城外部的实体可以触发代码执行。异步操作的例子可以是在时回调中执行一次简单的数学计算。
```javascript
let x = 3
setTimeout(() => x = x + 4, 1000)
```
这段代码中，执行线程不知道x值何时会改变，因为这取决于回调何时从消息队列出列并执行。
第二个指令块是由系统计时器出发，会生成一个入队执行的终端。到底什么时候会出发中断，对JavaScript运行时来说无法预知。无论如何，排定回调后基本没有办法直到系统状态何时变化。

为了让后续代码能够使用x，异步执行的函数需要在更新x值之后通知其他代码。

###以往的异步编程模式
在早期的JavaScript中，只支持定义回调函数来表明异步操作。串联多个异步操作是一个常见的问题，通常需要深度嵌套的回调函数（回调地狱）。
```javascript
function double(value) {
    setTimeout(() => setTimeout(console.log, 0, value * 2), 1000)
}
double(3) // 6 (大约1000毫秒之后)
```
setTimeout可以定义一个在指定时间之后会被调度执行的回调函数。对这个例子而言，1000毫秒之后，JavaScript运行时会把回调函数推到自己的消息队列上去等待执行，至于什么时候真正执行对JavaScript代码就完全不可见了。

