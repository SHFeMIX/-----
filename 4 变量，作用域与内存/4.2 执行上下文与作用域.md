变量或函数的上下文决定了它们可以访问那些数据。每一个上下文都有关联的变量对象，这个上下文中定义的所有变量和函数都存在这个对象上。无法通过代码访问，但是后台会用到。

全局上下文就是最外层的上下文，在浏览器中就是window对象，因此var定义的全局变量和函数都会成为window对象的属性和方法。上下文在其所有代码执行完毕后会销毁，包括定义在它上面的所有变量和函数。

每个函数调用都有自己的上下文，。当代码执行流进入函数时候=，函数的上下文被推到一个上下文栈上。函数执行完之后，上下文栈就会弹出该上下文，将控制权返回给之前的执行上下文。

上下文中的代码在执行的时候，会创建变量对象的一个**作用域链**，它决定了各级上下文中的代码在访问变量和函数时的顺序。代码在一个上下文中执行时，会首先在这个上下文的变量对象中搜索变量和函数名，如果没有找到，就会搜索父级上下文的变量对象，直到找到该变量或函数的标识符，或者抵达作用域链的末端，也就是全局上下文。
内部上下文可以通过作用域链访问外部上下文中的一切，但是外部上下文不能访问内部上下文中的任何东西。

### 作用域链增强
某些语句会导致在作用域链前端临时添加一个上下文，这个上下文会在代码执行后被移除。
* try/catch：一个包含要抛出的错误对象的变量对象被添加到作用域链前端
* with：向作用域链前端添加指定对象。

### 变量声明
**使用var的函数作用域声明**
在使用var声明变量时，会被自动添加到最接近的上下文。如果变量未经声明就被初始化了，那就会自动被添加到全局上下文。

var声明会被拿到函数或全局作用域顶部，位于作用域中所有代码之前。

**使用let的块级作用域声明**
块级作用域由最近的一对{}界定。

重复的var声明会被忽略，重复的let会报错。

严格来说，let也会有变量提升，但是因为暂时性死区，在声明之前访问会报错。