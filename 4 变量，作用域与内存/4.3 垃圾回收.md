垃圾回收程序每隔一段时间就会自动运行，确定那个变量不会再使用，然后释放它占用的内存。
某块内存是否还有用，属于不可判定问题，靠算法是解决不了的。

### 4.3.1 标记清理
当变量进入上下文，比如在函数内部声明一个变量，这个变量会被加上存在于上下文的标记。当变量离开上下文时，也会被加上离开上下文的标记。

给变量加标记的方式有很多种。比如当变量进入上下文时，反转某一位；或者可以维护“在上下文中“和”不在上下文中”两个列表。

垃圾回收程序运行时，会标记内存中存储的所有变量，然后将所有在上下文中的变量，以及呗在上下文中的变量引用的变量的标记去掉。在此之后再被加上标记的就是带删除的变量，因为任何上下文中的变量都访问不到它们。随后垃圾回收程序做一次内存清理，销毁所有带标记的值并回收它们所占用的内存空间。

### 引用计数
思路是对每个值都记录它被引用的次数。当一个值引用次数为0就说明没办法再访问到了，可以安全得释放。
但是遇到循环引用就g。

BOM和DOM中的对象是C++实现的组件对象模型（COM）。而COM对象使用引用计数实现垃圾回收。

循环引用问题可以通过手动解除引用来解决。

### 性能
IE7发布之后，JavaScript引擎的垃圾回收程序被调优为动态改变分配变量，字面量或数组槽位等会出发垃圾回收的阈值。如果一次垃圾回收的内存不足已分配的15%，阈值翻倍；如果一次回收的内存达到已分配的85%，阈值重置位默认值。

### 内存管理
**隐藏类**
V8在将解释后的JavaScript代码编译位世纪的机器码时会利用“隐藏类”。
运行期间，V8会将创建的对象与隐藏类关联起来。能够共享隐藏类的秀爱哪个性能会更好，但不一定总能够做到。
```javascript
function Article() {
    this.title = 'Inauguration Ceremony Features Kazoo Band';
}

let a1 = new Article();
let a2 = new Article();
```
V8会在后台配置，让这两个类实例共享隐藏类，因为这两个实例共享同一个构造函数和原型。但是如果在a1上添加一个属性，那么a1和a2就不再共享隐藏类了。

动态添加属性（a.author = 'Jake'）和动态删除属性（delete a.author）都会导致两个实例不再共享隐藏类。
最佳实践是避免“先创建再补充”，在构造函数中一声明所有属性，把不想要的属性设置为null。

```javascript
function Article() {
    this.title = 'Inauguration Ceremony Features Kazoo Band';
    this.author = 'Jake';
}

let a1 = new Article();
let a2 = new Article();

a1.author = null;
```

**内存泄漏**
闭包会导致内存泄漏。只要返回的函数存在就不能清理返回的函数引用的内部变量。