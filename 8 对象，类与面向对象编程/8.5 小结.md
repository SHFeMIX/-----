* 使用构造函数模式可以自定义引用类型，也可以使用new关键字像创建内置类型实例一样创建自定义的类型的实例。不过构造函数模式也有不足，主要是成员无法重用，包括函数。考虑到函数本身是松散的，弱类型的，没有理由让函数不能在多个对象实例间共享。

* 原型模式解决了成员共享的问题，只要是添加到构造函数prototype伤的属性和方法就可以共享。而组合构造函数和原型模式通过构造函数定义实例属性，通过原型定义共享的属性和方法。

JavaScript继承主要通过原型链来实现。原型链的构建是通过把构造函数的原型赋值为另一个类型（父类）的实例来实现。这样一来，子类就可以访问父类的所有属性和方法。原型链的问题是所有继承的属性和方法都会在对象实例间共享，无法做到实例私有。盗用构造函数模式通过在子类构造函数中调用父类构造函数来避免这个问题。这样可以让每个实例继承的属性都是私有的，但要求类型只能通过构造函数模式来定义（因为子类不能访问父类原型上的方法）。目前最流行的继承模式是组合继承，通过原型链继承共享的属性和方法，通过盗用构造函数继承实例属性。

还有以下几种继承模式
* 原型式继承可以无须明确定义构造函数而实现继承，本质上是给定对象执行浅复制。
* 与原型式继承紧密相关的事寄生式继承，即先基于一个对象创建一个新对象，然后再增强这个新对象，最后返回新对象。
* 寄生组合继承被认为是实现基于类型继承的最有效方式。

ES6新增的类很大程度上是基于既有原型机制的语法糖。类的语法可以让开发者优雅地定义向后兼容的类，既可以继承内置类型，也可以继承自定义类型。类有效地跨越了对象实例，对象原型和对象类之间的鸿沟。
